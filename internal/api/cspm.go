// Code generated by scripts/generate/main.go. DO NOT EDIT.
package api

import (
	"context"
	"fmt"
	"net/url"
	"strings"
)

// ListCspmFindings - Get CSPM Findings
// GET /cspm/findings
func (c *Client) ListCspmFindings(ctx context.Context, params url.Values) ([]byte, error) {
	path := "/cspm/findings"

	query := url.Values{}
	for k, v := range c.DefaultParams {
		query.Set(k, v)
	}
	if v := params.Get("azureOrganizationId"); v != "" {
		query.Set("azureOrganizationId", v)
	}
	if v := params.Get("bitbucketWorkspaceId"); v != "" {
		query.Set("bitbucketWorkspaceId", v)
	}
	if v := params.Get("githubOwnerId"); v != "" {
		query.Set("githubOwnerId", v)
	}
	if v := params.Get("gitlabGroupId"); v != "" {
		query.Set("gitlabGroupId", v)
	}
	if v := params.Get("installationId"); v != "" {
		query.Set("installationId", v)
	}
	if v := params.Get("azureRepositoryId"); v != "" {
		query.Set("azureRepositoryId", v)
	}
	if v := params.Get("githubRepositoryId"); v != "" {
		query.Set("githubRepositoryId", v)
	}
	if v := params.Get("githubTeamId"); v != "" {
		query.Set("githubTeamId", v)
	}
	if v := params.Get("bitbucketRepositoryId"); v != "" {
		query.Set("bitbucketRepositoryId", v)
	}
	if v := params.Get("limit"); v != "" {
		query.Set("limit", v)
	}
	if v := params.Get("nextToken"); v != "" {
		query.Set("nextToken", v)
	}
	if v := params.Get("sort"); v != "" {
		query.Set("sort", v)
	}
	if v := params.Get("sortBy"); v != "" {
		query.Set("sortBy", v)
	}
	if v := params.Get("severity"); v != "" {
		query.Set("severity", v)
	}
	if v := params.Get("status"); v != "" {
		query.Set("status", v)
	}
	if v := params.Get("accountId"); v != "" {
		query.Set("accountId", v)
	}
	if v := params.Get("region"); v != "" {
		query.Set("region", v)
	}
	if v := params.Get("resourceType"); v != "" {
		query.Set("resourceType", v)
	}
	if v := params.Get("scanId"); v != "" {
		query.Set("scanId", v)
	}

	fullURL := fmt.Sprintf("%s%s", c.BaseURL, path)
	if len(query) > 0 {
		fullURL += "?" + query.Encode()
	}

	return c.do(ctx, "GET", fullURL, nil)
}

// GetCspmFindingsFindingId - Get CSPM Finding
// GET /cspm/findings/{findingId}
func (c *Client) GetCspmFindingsFindingId(ctx context.Context, params url.Values) ([]byte, error) {
	path := "/cspm/findings/{findingId}"
	path = strings.Replace(path, "{findingId}", params.Get("findingId"), 1)

	query := url.Values{}
	for k, v := range c.DefaultParams {
		query.Set(k, v)
	}
	if v := params.Get("azureOrganizationId"); v != "" {
		query.Set("azureOrganizationId", v)
	}
	if v := params.Get("bitbucketWorkspaceId"); v != "" {
		query.Set("bitbucketWorkspaceId", v)
	}
	if v := params.Get("githubOwnerId"); v != "" {
		query.Set("githubOwnerId", v)
	}
	if v := params.Get("gitlabGroupId"); v != "" {
		query.Set("gitlabGroupId", v)
	}
	if v := params.Get("installationId"); v != "" {
		query.Set("installationId", v)
	}
	if v := params.Get("azureRepositoryId"); v != "" {
		query.Set("azureRepositoryId", v)
	}
	if v := params.Get("githubRepositoryId"); v != "" {
		query.Set("githubRepositoryId", v)
	}
	if v := params.Get("githubTeamId"); v != "" {
		query.Set("githubTeamId", v)
	}
	if v := params.Get("bitbucketRepositoryId"); v != "" {
		query.Set("bitbucketRepositoryId", v)
	}

	fullURL := fmt.Sprintf("%s%s", c.BaseURL, path)
	if len(query) > 0 {
		fullURL += "?" + query.Encode()
	}

	return c.do(ctx, "GET", fullURL, nil)
}

// ListCspmScans - Get CSPM Scans
// GET /cspm/scans
func (c *Client) ListCspmScans(ctx context.Context, params url.Values) ([]byte, error) {
	path := "/cspm/scans"

	query := url.Values{}
	for k, v := range c.DefaultParams {
		query.Set(k, v)
	}
	if v := params.Get("azureOrganizationId"); v != "" {
		query.Set("azureOrganizationId", v)
	}
	if v := params.Get("bitbucketWorkspaceId"); v != "" {
		query.Set("bitbucketWorkspaceId", v)
	}
	if v := params.Get("githubOwnerId"); v != "" {
		query.Set("githubOwnerId", v)
	}
	if v := params.Get("gitlabGroupId"); v != "" {
		query.Set("gitlabGroupId", v)
	}
	if v := params.Get("installationId"); v != "" {
		query.Set("installationId", v)
	}
	if v := params.Get("azureRepositoryId"); v != "" {
		query.Set("azureRepositoryId", v)
	}
	if v := params.Get("githubRepositoryId"); v != "" {
		query.Set("githubRepositoryId", v)
	}
	if v := params.Get("githubTeamId"); v != "" {
		query.Set("githubTeamId", v)
	}
	if v := params.Get("bitbucketRepositoryId"); v != "" {
		query.Set("bitbucketRepositoryId", v)
	}
	if v := params.Get("limit"); v != "" {
		query.Set("limit", v)
	}
	if v := params.Get("nextToken"); v != "" {
		query.Set("nextToken", v)
	}
	if v := params.Get("status"); v != "" {
		query.Set("status", v)
	}
	if v := params.Get("accountId"); v != "" {
		query.Set("accountId", v)
	}
	if v := params.Get("region"); v != "" {
		query.Set("region", v)
	}
	if v := params.Get("scanType"); v != "" {
		query.Set("scanType", v)
	}

	fullURL := fmt.Sprintf("%s%s", c.BaseURL, path)
	if len(query) > 0 {
		fullURL += "?" + query.Encode()
	}

	return c.do(ctx, "GET", fullURL, nil)
}

// GetCspmScansScanId - Get CSPM Scan
// GET /cspm/scans/{scanId}
func (c *Client) GetCspmScansScanId(ctx context.Context, params url.Values) ([]byte, error) {
	path := "/cspm/scans/{scanId}"
	path = strings.Replace(path, "{scanId}", params.Get("scanId"), 1)

	query := url.Values{}
	for k, v := range c.DefaultParams {
		query.Set(k, v)
	}
	if v := params.Get("azureOrganizationId"); v != "" {
		query.Set("azureOrganizationId", v)
	}
	if v := params.Get("bitbucketWorkspaceId"); v != "" {
		query.Set("bitbucketWorkspaceId", v)
	}
	if v := params.Get("githubOwnerId"); v != "" {
		query.Set("githubOwnerId", v)
	}
	if v := params.Get("gitlabGroupId"); v != "" {
		query.Set("gitlabGroupId", v)
	}
	if v := params.Get("installationId"); v != "" {
		query.Set("installationId", v)
	}
	if v := params.Get("azureRepositoryId"); v != "" {
		query.Set("azureRepositoryId", v)
	}
	if v := params.Get("githubRepositoryId"); v != "" {
		query.Set("githubRepositoryId", v)
	}
	if v := params.Get("githubTeamId"); v != "" {
		query.Set("githubTeamId", v)
	}
	if v := params.Get("bitbucketRepositoryId"); v != "" {
		query.Set("bitbucketRepositoryId", v)
	}

	fullURL := fmt.Sprintf("%s%s", c.BaseURL, path)
	if len(query) > 0 {
		fullURL += "?" + query.Encode()
	}

	return c.do(ctx, "GET", fullURL, nil)
}
