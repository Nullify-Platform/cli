package cmd

import (
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"os"
	"strings"

	"github.com/nullify-platform/cli/internal/auth"
	"github.com/nullify-platform/cli/internal/client"
	"github.com/nullify-platform/cli/internal/lib"
	"github.com/nullify-platform/logger/pkg/logger"
	"github.com/spf13/cobra"
)

var ciCmd = &cobra.Command{
	Use:   "ci",
	Short: "CI/CD integration commands",
	Long:  "Commands for integrating Nullify into CI/CD pipelines.",
}

var ciGateCmd = &cobra.Command{
	Use:   "gate",
	Short: "Quality gate - exit non-zero if findings exceed threshold",
	Long: `Check if security findings exceed the severity threshold and exit non-zero if they do.
Use this in CI/CD pipelines to block deployments with critical/high findings.

Exit codes:
  0 - No findings above threshold
  1 - Findings above threshold found (or error)`,
	Run: func(cmd *cobra.Command, args []string) {
		ctx := setupLogger()
		defer logger.L(ctx).Sync()

		ciHost := resolveHost(ctx)
		token, err := lib.GetNullifyToken(ctx, ciHost, nullifyToken, githubToken)
		if err != nil {
			fmt.Fprintf(os.Stderr, "Error: not authenticated\n")
			os.Exit(1)
		}

		nullifyClient := client.NewNullifyClient(ciHost, token)

		creds, err := auth.LoadCredentials()
		queryParams := map[string]string{}
		if err == nil {
			if hostCreds, ok := creds[ciHost]; ok && hostCreds.QueryParameters != nil {
				queryParams = hostCreds.QueryParameters
			}
		}

		severityThreshold, _ := cmd.Flags().GetString("severity-threshold")
		findingType, _ := cmd.Flags().GetString("type")
		repo, _ := cmd.Flags().GetString("repo")

		if repo == "" {
			repo = lib.DetectRepoFromGit()
		}

		severities := severitiesAboveThreshold(severityThreshold)

		endpoints := getCIEndpoints(findingType)

		totalFindings := 0
		for _, ep := range endpoints {
			for _, sev := range severities {
				params := []string{"severity", sev, "status", "open", "limit", "1"}
				if repo != "" {
					params = append(params, "repository", repo)
				}
				qs := buildCIQueryString(queryParams, params...)

				body, err := doCIGet(nullifyClient, ep.path+qs)
				if err != nil {
					continue
				}

				count := countFindings(body)
				if count > 0 {
					totalFindings += count
					fmt.Printf("FAIL: %s has %d %s findings\n", ep.name, count, sev)
				}
			}
		}

		if totalFindings > 0 {
			fmt.Printf("\nGate failed: %d findings at or above %s severity\n", totalFindings, severityThreshold)
			os.Exit(1)
		}

		fmt.Println("Gate passed: no findings above threshold")
	},
}

var ciReportCmd = &cobra.Command{
	Use:   "report",
	Short: "Generate a markdown summary for PR comments",
	Long:  "Output a markdown summary of security findings suitable for PR comments. Shows counts by type and severity.",
	Run: func(cmd *cobra.Command, args []string) {
		ctx := setupLogger()
		defer logger.L(ctx).Sync()

		ciHost := resolveHost(ctx)
		token, err := lib.GetNullifyToken(ctx, ciHost, nullifyToken, githubToken)
		if err != nil {
			fmt.Fprintf(os.Stderr, "Error: not authenticated\n")
			os.Exit(1)
		}

		nullifyClient := client.NewNullifyClient(ciHost, token)

		creds, err := auth.LoadCredentials()
		queryParams := map[string]string{}
		if err == nil {
			if hostCreds, ok := creds[ciHost]; ok && hostCreds.QueryParameters != nil {
				queryParams = hostCreds.QueryParameters
			}
		}

		repo, _ := cmd.Flags().GetString("repo")
		if repo == "" {
			repo = lib.DetectRepoFromGit()
		}

		endpoints := getCIEndpoints("")

		fmt.Println("## Nullify Security Report")
		fmt.Println()
		fmt.Println("| Scanner | Severity | Count |")
		fmt.Println("|---------|----------|-------|")

		for _, ep := range endpoints {
			for _, sev := range []string{"critical", "high", "medium", "low"} {
				params := []string{"severity", sev, "status", "open", "limit", "1"}
				if repo != "" {
					params = append(params, "repository", repo)
				}
				qs := buildCIQueryString(queryParams, params...)

				body, err := doCIGet(nullifyClient, ep.path+qs)
				if err != nil {
					continue
				}

				count := countFindings(body)
				if count > 0 {
					fmt.Printf("| %s | %s | %d |\n", ep.name, sev, count)
				}
			}
		}

		fmt.Println()
		fmt.Println("*Generated by [Nullify CLI](https://github.com/nullify-platform/cli)*")
	},
}

func init() {
	rootCmd.AddCommand(ciCmd)
	ciCmd.AddCommand(ciGateCmd)
	ciCmd.AddCommand(ciReportCmd)

	ciGateCmd.Flags().String("severity-threshold", "high", "Minimum severity to fail on (critical, high, medium, low)")
	ciGateCmd.Flags().String("type", "", "Filter by finding type (sast, sca, secrets, pentest, bughunt, cspm)")
	ciGateCmd.Flags().String("repo", "", "Repository name (auto-detected from git if not set)")

	ciReportCmd.Flags().String("repo", "", "Repository name (auto-detected from git if not set)")
}

type ciEndpoint struct {
	name string
	path string
}

func getCIEndpoints(findingType string) []ciEndpoint {
	all := []ciEndpoint{
		{"SAST", "/sast/findings"},
		{"SCA Dependencies", "/sca/dependencies/findings"},
		{"SCA Containers", "/sca/containers/findings"},
		{"Secrets", "/secrets/findings"},
		{"Pentest", "/dast/pentest/findings"},
		{"BugHunt", "/dast/bughunt/findings"},
		{"CSPM", "/cspm/findings"},
	}

	if findingType == "" {
		return all
	}

	typeMap := map[string]string{
		"sast":    "SAST",
		"sca":     "SCA Dependencies",
		"secrets": "Secrets",
		"pentest": "Pentest",
		"bughunt": "BugHunt",
		"cspm":    "CSPM",
	}

	target, ok := typeMap[findingType]
	if !ok {
		return all
	}

	for _, ep := range all {
		if ep.name == target {
			return []ciEndpoint{ep}
		}
	}

	return all
}

func severitiesAboveThreshold(threshold string) []string {
	all := []string{"critical", "high", "medium", "low"}
	for i, s := range all {
		if s == threshold {
			return all[:i+1]
		}
	}
	return []string{"critical", "high"}
}

func countFindings(body string) int {
	var result interface{}
	if err := json.Unmarshal([]byte(body), &result); err != nil {
		return 0
	}

	switch v := result.(type) {
	case []interface{}:
		return len(v)
	case map[string]interface{}:
		if items, ok := v["items"].([]interface{}); ok {
			return len(items)
		}
		if total, ok := v["total"].(float64); ok {
			return int(total)
		}
	}

	return 0
}

func buildCIQueryString(base map[string]string, extra ...string) string {
	parts := []string{}
	for k, v := range base {
		parts = append(parts, fmt.Sprintf("%s=%s", k, v))
	}
	for i := 0; i+1 < len(extra); i += 2 {
		if extra[i+1] != "" {
			parts = append(parts, fmt.Sprintf("%s=%s", extra[i], extra[i+1]))
		}
	}
	if len(parts) == 0 {
		return ""
	}
	return "?" + strings.Join(parts, "&")
}

func doCIGet(c *client.NullifyClient, path string) (string, error) {
	req, err := http.NewRequest("GET", c.BaseURL+path, nil)
	if err != nil {
		return "", err
	}

	resp, err := c.HttpClient.Do(req)
	if err != nil {
		return "", err
	}
	defer resp.Body.Close()

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return "", err
	}

	if resp.StatusCode < 200 || resp.StatusCode >= 300 {
		return "", fmt.Errorf("API returned %d", resp.StatusCode)
	}

	return string(body), nil
}
